"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var es6_promise_1 = require("es6-promise");
var Token = require("token-types");
var ID3v1Parser_1 = require("../id3v1/ID3v1Parser");
var FourCC_1 = require("../common/FourCC");
/**
 * Interface for the parsed Media Atom (mdhd)
 */
var Atom = /** @class */ (function () {
    function Atom() {
    }
    Atom.Header = {
        len: 8,
        get: function (buf, off) {
            var length = Token.UINT32_BE.get(buf, 0);
            if (length < 0)
                throw new Error("Invalid atom header length");
            return {
                length: length,
                name: FourCC_1.FourCcToken.get(buf, off + 4)
            };
        }
    };
    Atom.ftyp = {
        len: 4,
        get: function (buf, off) {
            return {
                type: new Token.StringType(4, "ascii").get(buf, off)
            };
        }
    };
    /**
     * Token: Media Header Atom
     */
    Atom.mdhd = {
        len: 24,
        get: function (buf, off) {
            return {
                version: Token.UINT8.get(buf, off + 0),
                flags: Token.UINT24_BE.get(buf, off + 1),
                creationTime: Token.UINT32_BE.get(buf, off + 4),
                modificationTime: Token.UINT32_BE.get(buf, off + 8),
                timeScale: Token.UINT32_BE.get(buf, off + 12),
                duration: Token.UINT32_BE.get(buf, off + 16),
                language: Token.UINT16_BE.get(buf, off + 20),
                quality: Token.UINT16_BE.get(buf, off + 22)
            };
        }
    };
    /**
     * Token: Movie Header Atom
     */
    Atom.mvhd = {
        len: 100,
        get: function (buf, off) {
            return {
                version: Token.UINT8.get(buf, off + 0),
                flags: Token.UINT24_BE.get(buf, off + 1),
                creationTime: Token.UINT32_BE.get(buf, off + 4),
                modificationTime: Token.UINT32_BE.get(buf, off + 8),
                timeScale: Token.UINT32_BE.get(buf, off + 12),
                duration: Token.UINT32_BE.get(buf, off + 16),
                preferredRate: Token.UINT32_BE.get(buf, off + 20),
                preferredVolume: Token.UINT16_BE.get(buf, off + 24),
                // ignore reserver: 10 bytes
                // ignore matrix structure: 36 bytes
                previewTime: Token.UINT32_BE.get(buf, off + 72),
                previewDuration: Token.UINT32_BE.get(buf, off + 76),
                posterTime: Token.UINT32_BE.get(buf, off + 80),
                selectionTime: Token.UINT32_BE.get(buf, off + 84),
                selectionDuration: Token.UINT32_BE.get(buf, off + 88),
                currentTime: Token.UINT32_BE.get(buf, off + 92),
                nextTrackID: Token.UINT32_BE.get(buf, off + 96)
            };
        }
    };
    /**
     * Token: Movie Header Atom
     */
    Atom.mhdr = {
        len: 8,
        get: function (buf, off) {
            return {
                version: Token.UINT8.get(buf, off + 0),
                flags: Token.UINT24_BE.get(buf, off + 1),
                nextItemID: Token.UINT32_BE.get(buf, off + 4)
            };
        }
    };
    return Atom;
}());
/**
 * Data Atom Structure
 */
var DataAtom = /** @class */ (function () {
    function DataAtom(len) {
        this.len = len;
    }
    DataAtom.prototype.get = function (buf, off) {
        return {
            type: {
                set: Token.UINT8.get(buf, off + 0),
                type: Token.UINT24_BE.get(buf, off + 1)
            },
            locale: Token.UINT24_BE.get(buf, off + 4),
            value: new Token.BufferType(this.len - 8).get(buf, off + 8)
        };
    };
    return DataAtom;
}());
/**
 * Data Atom Structure
 * Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW31
 */
var NameAtom = /** @class */ (function () {
    function NameAtom(len) {
        this.len = len;
    }
    NameAtom.prototype.get = function (buf, off) {
        return {
            version: Token.UINT8.get(buf, off),
            flags: Token.UINT24_BE.get(buf, off + 1),
            name: new Token.StringType(this.len - 4, "utf-8").get(buf, off + 4)
        };
    };
    return NameAtom;
}());
/*
 * Support for Apple iTunes MP4 tags as found in a M4A/MP4 file
 * Ref:
 *   http://developer.apple.com/mac/library/documentation/QuickTime/QTFF/Metadata/Metadata.html
 *   http://atomicparsley.sourceforge.net/mpeg-4files.html
 */
var MP4Parser = /** @class */ (function () {
    function MP4Parser() {
        this.metaAtomsTotalLength = 0;
        this.format = {};
        this.tags = [];
        this.warnings = []; // ToDo: make this part of the parsing result
    }
    MP4Parser.read_BE_Signed_Integer = function (value) {
        return value.readIntBE(0, value.length);
    };
    MP4Parser.read_BE_Unsigned_Integer = function (value) {
        return value.readUIntBE(0, value.length);
    };
    MP4Parser.prototype.parse = function (tokenizer, options) {
        var _this = this;
        this.tokenizer = tokenizer;
        this.options = options;
        return this.parseAtom().then(function () {
            return {
                format: _this.format,
                native: {
                    "iTunes MP4": _this.tags
                }
            };
        });
    };
    MP4Parser.prototype.parseAtom = function () {
        var _this = this;
        // Parse atom header
        return this.tokenizer.readToken(Atom.Header).then(function (header) {
            return _this.parseAtomData(header).then(function (done) {
                if (done) {
                    // ToDo: messy ending
                    // console.log("Done with %s", header.name);
                    return done;
                }
                else {
                    return _this.parseAtom();
                }
            });
        });
    };
    MP4Parser.prototype.parseAtomData = function (header) {
        var dataLen = header.length - 8;
        // console.log("atom name=%s, len=%s", header.name, header.length);
        switch (header.name) {
            case "ftyp":
                return this.parseAtom_ftyp(dataLen).then(function (types) {
                    return false;
                });
            // "Container" atoms, contain nested atoms: 'moov', 'udta', 'meta', 'ilst', 'trak', 'mdia'
            case "moov": // The Movie Atom: contains other atoms
            case "udta": // User defined atom
            case "trak":
            case "mdia": // Media atom
            case "minf": // Media Information Atom
            case "stbl":// Media Information Atom
                return this.parseAtom().then(function (done) { return done; });
            case "meta":// Metadata Atom, ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW8
                return this.tokenizer.readToken(new Token.IgnoreType(4)).then(function () { return false; }); // meta has 4 bytes of padding, ignore
            case "ilst":// 'meta' => 'ilst': Metadata Item List Atom
                // Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW24
                return this.parseMetadataItem(dataLen).then(function () { return false; });
            case "mdhd":// Media header atom
                return this.parseAtom_mdhd(dataLen).then(function () { return false; });
            case "mvhd":// 'movie' => 'mvhd': movie header atom; child of Movie Atom
                return this.parseAtom_mvhd(dataLen).then(function () { return false; });
            case "<id>":// 'meta' => 'ilst' => '<id>': metadata item atom
                return this.parseMetadataItem(dataLen).then(function () { return false; });
            case "cmov": // compressed movie atom; child of Movie Atom
            case "rmra": // reference movie atom; child of Movie Atom
            case "mdat":
                return es6_promise_1.Promise.resolve(true);
            default:
                // return this.ignoreAtomData(dataLen);
                return this.tokenizer.readToken(new Token.BufferType(dataLen)).then(function (buf) {
                    // console.log("  ascii: %s", header.name, header.length, buf.toString('ascii'));
                    buf = buf;
                }).then(function () { return false; });
        }
    };
    MP4Parser.prototype.ignoreAtomData = function (len) {
        return this.tokenizer.readToken(new Token.IgnoreType(len));
    };
    MP4Parser.prototype.parseAtom_ftyp = function (len) {
        var _this = this;
        return this.tokenizer.readToken(Atom.ftyp).then(function (ftype) {
            len -= Atom.ftyp.len;
            if (len > 0) {
                return _this.parseAtom_ftyp(len).then(function (types) {
                    types.push(ftype.type);
                    return types;
                });
            }
            else {
                return [];
            }
        });
    };
    /**
     * Parse movie header (mvhd) atom
     * @param len
     */
    MP4Parser.prototype.parseAtom_mvhd = function (len) {
        var _this = this;
        return this.tokenizer.readToken(Atom.mvhd).then(function (mvhd) {
            _this.parse_mxhd(mvhd);
        });
    };
    /**
     * Parse media header (mdhd) atom
     * @param len
     */
    MP4Parser.prototype.parseAtom_mdhd = function (len) {
        var _this = this;
        return this.tokenizer.readToken(Atom.mdhd).then(function (mdhd) {
            _this.parse_mxhd(mdhd);
        });
    };
    MP4Parser.prototype.parse_mxhd = function (mxhd) {
        this.format.sampleRate = mxhd.timeScale;
        this.format.duration = mxhd.duration / mxhd.timeScale; // calculate duration in seconds
    };
    /**
     * Parse media header (ilst) atom
     * @param len
     * Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW8
     */
    /*
     private parseMetadataItem(len: number): Promise<void>{
     // Parse atom header
     return this.tokenizer.readToken<IAtomHeader>(Atom.Header).then((header) => {
  
     return this.parseAtomData(header);
     });
     }*/
    /**
     * Parse Meta-item-list-atom (item of 'ilst' atom)
     * @param len
     * Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW8
     */
    MP4Parser.prototype.parseMetadataItem = function (len) {
        var _this = this;
        // Parse atom header
        return this.tokenizer.readToken(Atom.Header).then(function (header) {
            // console.log("metadata-item: name=%s, len=%s", header.name, header.length);
            return _this.parseMetadataItemData(header.name, header.length - Atom.Header.len).then(function () {
                var remaining = len - Atom.Header.len - header.length;
                if (remaining > 0) {
                    return _this.parseMetadataItem(remaining);
                }
                else
                    return;
            });
        });
    };
    MP4Parser.prototype.parseMetadataItemData = function (tagKey, remLen) {
        var _this = this;
        // Parse Meta Item List Atom
        return this.tokenizer.readToken(Atom.Header).then(function (header) {
            var dataLen = header.length - Atom.Header.len;
            switch (header.name) {
                case "data":// value atom
                    return _this.parseValueAtom(tagKey, header);
                case "itif":// item information atom (optional)
                    return _this.tokenizer.readToken(new Token.BufferType(dataLen)).then(function (dataAtom) {
                        // console.log("  WARNING unsupported meta-item: %s[%s] => value=%s ascii=%s", tagKey, header.name, dataAtom.toString("hex"), dataAtom.toString("ascii"));
                        return header.length;
                    });
                case "name":// name atom (optional)
                    return _this.tokenizer.readToken(new NameAtom(dataLen)).then(function (name) {
                        tagKey += ":" + name.name;
                        return header.length;
                    });
                case "mean":// name atom (optional)
                    return _this.tokenizer.readToken(new NameAtom(dataLen)).then(function (mean) {
                        // console.log("  %s[%s] = %s", tagKey, header.name, mean.name);
                        tagKey += ":" + mean.name;
                        return header.length;
                    });
                default:
                    return _this.tokenizer.readToken(new Token.BufferType(dataLen)).then(function (dataAtom) {
                        // console.log("  WARNING unsupported meta-item: %s[%s] => value=%s ascii=%s", tagKey, header.name, dataAtom.toString("hex"), dataAtom.toString("ascii"));
                        _this.warnings.push("unsupported meta-item: " + tagKey + "[" + header.name + "] => value=" + dataAtom.toString("hex") + " ascii=" + dataAtom.toString("ascii"));
                        return header.length;
                    });
            }
        }).then(function (len) {
            var remaining = remLen - len;
            if (remaining === 0) {
                return;
            }
            else {
                return _this.parseMetadataItemData(tagKey, remaining);
            }
        });
    };
    MP4Parser.prototype.parseValueAtom = function (tagKey, header) {
        var _this = this;
        return this.tokenizer.readToken(new DataAtom(header.length - Atom.Header.len)).then(function (dataAtom) {
            if (dataAtom.type.set === 0) {
                // Use well-known-type table
                // Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW35
                switch (dataAtom.type.type) {
                    case 0:// reserved: Reserved for use where no type needs to be indicated
                        switch (tagKey) {
                            case "trkn":
                            case "disk":
                                var num = Token.UINT8.get(dataAtom.value, 3);
                                var of = Token.UINT8.get(dataAtom.value, 5);
                                // console.log("  %s[data] = %s/%s", tagKey, num, of);
                                _this.tags.push({ id: tagKey, value: num + "/" + of });
                                break;
                            case "gnre":
                                var genreInt = Token.UINT8.get(dataAtom.value, 1);
                                var genreStr = ID3v1Parser_1.Genres[genreInt - 1];
                                // console.log("  %s[data] = %s", tagKey, genreStr);
                                _this.tags.push({ id: tagKey, value: genreStr });
                                break;
                            default:
                        }
                        break;
                    case 1:// UTF-8: Without any count or NULL terminator
                        _this.tags.push({ id: tagKey, value: dataAtom.value.toString("utf-8") });
                        break;
                    case 13:// JPEG
                        if (_this.options.skipCovers)
                            break;
                        _this.tags.push({
                            id: tagKey, value: {
                                format: "image/jpeg",
                                data: new Buffer(dataAtom.value)
                            }
                        });
                        break;
                    case 14:// PNG
                        if (_this.options.skipCovers)
                            break;
                        _this.tags.push({
                            id: tagKey, value: {
                                format: "image/png",
                                data: new Buffer(dataAtom.value)
                            }
                        });
                        break;
                    case 21:// BE Signed Integer
                        _this.tags.push({ id: tagKey, value: MP4Parser.read_BE_Signed_Integer(dataAtom.value) });
                        break;
                    case 22:// BE Unsigned Integer
                        _this.tags.push({ id: tagKey, value: MP4Parser.read_BE_Unsigned_Integer(dataAtom.value) });
                        break;
                    case 65:// An 8-bit signed integer
                        _this.tags.push({ id: tagKey, value: dataAtom.value.readInt8(0) });
                        break;
                    case 66:// A big-endian 16-bit signed integer
                        _this.tags.push({ id: tagKey, value: dataAtom.value.readInt16BE(0) });
                        break;
                    case 67:// A big-endian 32-bit signed integer
                        _this.tags.push({ id: tagKey, value: dataAtom.value.readInt32BE(0) });
                        break;
                    default:
                        throw new Error("Unsupported well-known-type: " + dataAtom.type.type);
                }
            }
            else {
                throw new Error("Unsupported type-set != 0: " + dataAtom.type.set);
            }
            return header.length;
        });
    };
    MP4Parser.Types = {
        0: "uint8",
        1: "text",
        13: "jpeg",
        14: "png",
        21: "uint8"
    };
    return MP4Parser;
}());
exports.MP4Parser = MP4Parser;
