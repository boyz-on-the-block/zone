'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
var Vorbis = require("./Vorbis");
var then_read_stream_1 = require("then-read-stream");
var Token = require("token-types");
/**
 * Vorbis 1 Parser.
 * Used by OggParser
 */
var VorbisParser = /** @class */ (function () {
    function VorbisParser() {
        this.format = {};
        this.tags = [];
    }
    VorbisParser.prototype.parse = function (tokenizer, options) {
        var _this = this;
        this.tokenizer = tokenizer;
        this.options = options;
        return this.parseHeaderPacket().then(function () {
            return {
                format: _this.format,
                native: {
                    vorbis: _this.tags
                }
            };
        });
    };
    /**
     * Vorbis 1 parser
     * @param pageLength
     * @returns {Promise<void>}
     */
    VorbisParser.prototype.parseHeaderPacket = function () {
        var _this = this;
        return this.tokenizer.readToken(Vorbis.CommonHeader).then(function (header) {
            if (header.vorbis !== 'vorbis')
                throw new Error('Metadata does not look like Vorbis');
            return _this.parsePacket(header.packetType).then(function (res) {
                if (!res.done) {
                    return _this.parseHeaderPacket();
                }
            });
        }).catch(function (err) {
            if (err.message === then_read_stream_1.endOfStream) {
                return;
            }
            else
                throw err;
        });
    };
    VorbisParser.prototype.parsePacket = function (packetType) {
        switch (packetType) {
            case 1://  type 1: the identification header
                return this.parseVorbisInfo().then(function (len) {
                    return { len: len, done: false };
                });
            case 3://  type 3: comment header
                return this.parseUserCommentList().then(function (len) {
                    return { len: len, done: true };
                });
            case 5:// type 5: setup header type
                throw new Error("'setup header type' not implemented");
        }
    };
    VorbisParser.prototype.parseVorbisInfo = function () {
        var _this = this;
        return this.tokenizer.readToken(Vorbis.IdentificationHeader).then(function (vi) {
            _this.format.sampleRate = vi.sampleRate;
            _this.format.bitrate = vi.bitrateNominal;
            _this.format.numberOfChannels = vi.channelMode;
            return Vorbis.IdentificationHeader.len;
        });
    };
    /**
     * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-840005.2
     * @returns {Promise<number>}
     */
    VorbisParser.prototype.parseUserCommentList = function () {
        var _this = this;
        return this.tokenizer.readToken(Token.UINT32_LE).then(function (strLen) {
            return _this.tokenizer.readToken(new Token.StringType(strLen, 'utf-8')).then(function (vendorString) {
                return _this.tokenizer.readToken(Token.UINT32_LE).then(function (userCommentListLength) {
                    return _this.parseUserComment(userCommentListLength).then(function (len) {
                        return 2 * Token.UINT32_LE.len + strLen + len;
                    });
                });
            });
        });
    };
    VorbisParser.prototype.parseUserComment = function (userCommentListLength) {
        var _this = this;
        return this.tokenizer.readToken(Token.UINT32_LE).then(function (strLen) {
            return _this.tokenizer.readToken(new Token.StringType(strLen, 'ascii')).then(function (v) {
                var idx = v.indexOf('=');
                var key = v.slice(0, idx).toUpperCase();
                var value = v.slice(idx + 1);
                if (key === 'METADATA_BLOCK_PICTURE') {
                    value = _this.options.skipCovers ? null : Vorbis.VorbisPictureToken.fromBase64(value);
                }
                if (value !== null)
                    _this.tags.push({ id: key, value: value });
                var len = Token.UINT32_LE.len + strLen;
                if (--userCommentListLength > 0) {
                    // if we don't want to read the duration
                    // then tell the parent stream to stop
                    // stop = !readDuration;
                    return _this.parseUserComment(userCommentListLength).then(function (recLen) {
                        return len + recLen;
                    });
                }
                return strLen;
            });
        });
    };
    return VorbisParser;
}());
exports.VorbisParser = VorbisParser;
