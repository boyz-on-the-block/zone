'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
var Common_1 = require("./common/Common");
var tagmap_1 = require("./tagmap");
var ParserFactory_1 = require("./ParserFactory");
var MusicMetadataParser = /** @class */ (function () {
    function MusicMetadataParser() {
        /**
         * ToDo: move to respective format implementations
         */
        /*
        private static headerTypes = [
          {
            buf: GUID.HeaderObject.toBin(),
            tag: require('./asf/AsfParser')
          },
          {
            buf: new Buffer('ID3'),
            tag: require('./id3v2')
          },
          {
            buf: new Buffer('ftypM4A'),
            tag: require('./id4'),
            offset: 4
          },
          {
            buf: new Buffer('ftypmp42'),
            tag: require('./id4'),
            offset: 4
          },
          {
            buf: new Buffer('OggS'),
            tag: require('./ogg')
          },
          {
            buf: new Buffer('fLaC'),
            tag: require('./flac')
          },
          {
            buf: new Buffer('MAC'),
            tag: require('./monkeysaudio')
          }
        ];*/
        this.tagMap = new tagmap_1.default();
    }
    MusicMetadataParser.getInstance = function () {
        return new MusicMetadataParser();
    };
    MusicMetadataParser.toIntOrNull = function (str) {
        var cleaned = parseInt(str, 10);
        return isNaN(cleaned) ? null : cleaned;
    };
    // TODO: a string of 1of1 would fail to be converted
    // converts 1/10 to no : 1, of : 10
    // or 1 to no : 1, of : 0
    MusicMetadataParser.cleanupTrack = function (origVal) {
        var split = origVal.toString().split('/');
        return {
            no: parseInt(split[0], 10) || null,
            of: parseInt(split[1], 10) || null
        };
    };
    MusicMetadataParser.cleanupPicture = function (picture) {
        var newFormat;
        if (picture.format) {
            var split = picture.format.toLowerCase().split('/');
            newFormat = (split.length > 1) ? split[1] : split[0];
            if (newFormat === 'jpeg')
                newFormat = 'jpg';
        }
        else {
            newFormat = 'jpg';
        }
        return { format: newFormat, data: picture.data };
    };
    /**
     * Extract metadata from the given audio file
     * @param filePath File path of the audio file to parse
     * @param opts
     *   .filesize=true  Return filesize
     *   .native=true    Will return original header in result
     * @returns {Promise<IAudioMetadata>}
     */
    MusicMetadataParser.prototype.parseFile = function (filePath, opts) {
        var _this = this;
        if (opts === void 0) { opts = {}; }
        return ParserFactory_1.ParserFactory.parseFile(filePath, opts).then(function (nativeData) {
            return _this.parseNativeTags(nativeData, opts.native);
        });
    };
    /**
     * Extract metadata from the given audio file
     * @param stream Audio ReadableStream
     * @param mimeType Mime-Type of Stream
     * @param opts
     *   .filesize=true  Return filesize
     *   .native=true    Will return original header in result
     * @returns {Promise<IAudioMetadata>}
     */
    MusicMetadataParser.prototype.parseStream = function (stream, mimeType, opts) {
        var _this = this;
        if (opts === void 0) { opts = {}; }
        return ParserFactory_1.ParserFactory.parseStream(stream, mimeType, opts).then(function (nativeData) {
            return _this.parseNativeTags(nativeData, opts.native);
        });
    };
    /**
     * Convert native tags to common tags
     * @param nativeData
     * @includeNative return native tags in result
     * @returns {IAudioMetadata} Native + common tags
     */
    MusicMetadataParser.prototype.parseNativeTags = function (nativeData, includeNative) {
        var metadata = {
            format: nativeData.format,
            native: includeNative ? nativeData.native : undefined,
            common: {
                track: { no: null, of: null },
                disk: { no: null, of: null }
            }
        };
        metadata.format.tagTypes = [];
        for (var tagType in nativeData.native) {
            metadata.format.tagTypes.push(tagType);
        }
        for (var _i = 0, TagPriority_1 = tagmap_1.TagPriority; _i < TagPriority_1.length; _i++) {
            var tagType = TagPriority_1[_i];
            if (nativeData.native[tagType]) {
                for (var _a = 0, _b = nativeData.native[tagType]; _a < _b.length; _a++) {
                    var tag = _b[_a];
                    this.setCommonTags(metadata.common, tagType, tag.id, tag.value);
                }
                break;
            }
        }
        if (metadata.common.artists && metadata.common.artists.length > 0) {
            metadata.common.artist = metadata.common.artist[0];
        }
        else {
            if (metadata.common.artist) {
                metadata.common.artists = metadata.common.artist;
                if (metadata.common.artist.length > 1) {
                    delete metadata.common.artist;
                }
                else {
                    metadata.common.artist = metadata.common.artist[0];
                }
            }
        }
        return metadata;
    };
    /**
     * Process and set common tags
     * @param comTags Target metadata to wrote common tags to
     * @param type    Native tagTypes e.g.: 'iTunes MP4' | 'asf' | 'ID3v1.1' | 'ID3v2.4' | 'vorbis'
     * @param tag     Native tag
     * @param value   Native tag value
     */
    MusicMetadataParser.prototype.setCommonTags = function (comTags, type, tag, value) {
        switch (type) {
            /*
             case 'vorbis':
             switch (tag) {
      
             case 'TRACKTOTAL':
             case 'TOTALTRACKS': // rare tag
             comTags.track.of = MusicMetadataParser.toIntOrNull(value)
             return
      
             case 'DISCTOTAL':
             case 'TOTALDISCS': // rare tag
             comTags.disk.of = MusicMetadataParser.toIntOrNull(value)
             return
             default:
             }
             break
             */
            case 'ID3v2.3':
            case 'ID3v2.4':
                switch (tag) {
                    /*
                     case 'TXXX':
                     tag += ':' + value.description
                     value = value.text
                     break*/
                    case 'UFID':// decode MusicBrainz Recording Id
                        if (value.owner_identifier === 'http://musicbrainz.org') {
                            tag += ':' + value.owner_identifier;
                            value = Common_1.default.decodeString(value.identifier, 'iso-8859-1');
                        }
                        break;
                    case 'PRIV':
                        switch (value.owner_identifier) {
                            // decode Windows Media Player
                            case 'AverageLevel':
                            case 'PeakValue':
                                tag += ':' + value.owner_identifier;
                                value = value.data.readUInt32LE();
                                break;
                            default:
                        }
                        break;
                    case 'MCDI':
                        break;
                    default:
                }
                break;
            default:
        }
        // Convert native tag event to common (aliased) event
        var alias = this.tagMap.getCommonName(type, tag);
        if (alias) {
            // Common tag (alias) found
            // check if we need to do something special with common tag
            // if the event has been aliased then we need to clean it before
            // it is emitted to the user. e.g. genre (20) -> Electronic
            switch (alias) {
                case 'genre':
                    value = Common_1.default.parseGenre(value);
                    break;
                case 'barcode':
                    value = typeof value === 'string' ? parseInt(value, 10) : value;
                    break;
                case 'picture':
                    value = MusicMetadataParser.cleanupPicture(value);
                    break;
                case 'totaltracks':
                    comTags.track.of = MusicMetadataParser.toIntOrNull(value);
                    return;
                case 'totaldiscs':
                    comTags.disk.of = MusicMetadataParser.toIntOrNull(value);
                    return;
                case 'track':
                case 'disk':
                    var of = comTags[alias].of; // store of value, maybe maybe overwritten
                    comTags[alias] = MusicMetadataParser.cleanupTrack(value);
                    comTags[alias].of = of != null ? of : comTags[alias].of;
                    return;
                case 'year':
                case 'originalyear':
                    value = parseInt(value, 10);
                    break;
                case 'date':
                    // ToDo: be more strict on 'YYYY...'
                    var year = parseInt(value.substr(0, 4), 10);
                    if (year && !isNaN(year)) {
                        comTags.year = year;
                    }
                    break;
                case 'discogs_release_id':
                    value = typeof value === 'string' ? parseInt(value, 10) : value;
                    break;
                case 'replaygain_track_peak':
                    value = typeof value === 'string' ? parseFloat(value) : value;
                    break;
                default:
            }
            if (alias !== 'artist' && tagmap_1.default.isSingleton(alias)) {
                comTags[alias] = value;
            }
            else {
                if (comTags.hasOwnProperty(alias)) {
                    comTags[alias].push(value);
                }
                else {
                    // if we haven't previously seen this tag then
                    // initialize it to an array, ready for values to be entered
                    comTags[alias] = [value];
                }
            }
        }
    };
    return MusicMetadataParser;
}());
exports.MusicMetadataParser = MusicMetadataParser;
/**
 * Parse audio file
 * @param filePath Media file to read meta-data from
 * @param options Parsing options:
 *   .native=true    Will return original header in result
 * @returns {Promise<IAudioMetadata>}
 */
function parseFile(filePath, options) {
    return MusicMetadataParser.getInstance().parseFile(filePath, options);
}
exports.parseFile = parseFile;
/**
 * Parse audio Stream
 * @param stream
 * @param mimeType
 * @param opts Parsing options
 *   .native=true    Will return original header in result
 * @returns {Promise<IAudioMetadata>}
 */
function parseStream(stream, mimeType, opts) {
    return MusicMetadataParser.getInstance().parseStream(stream, mimeType, opts);
}
exports.parseStream = parseStream;
/**
 * Create a dictionary ordered by their tag id (key)
 * @param nativeTags list of tags
 * @returns tags indexed by id
 */
function orderTags(nativeTags) {
    var tags = {};
    for (var _i = 0, nativeTags_1 = nativeTags; _i < nativeTags_1.length; _i++) {
        var tag = nativeTags_1[_i];
        (tags[tag.id] = (tags[tag.id] || [])).push(tag.value);
    }
    return tags;
}
exports.orderTags = orderTags;
