"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var APEv2Parser_1 = require("./apev2/APEv2Parser");
var AsfParser_1 = require("./asf/AsfParser");
var FlacParser_1 = require("./flac/FlacParser");
var MP4Parser_1 = require("./mp4/MP4Parser");
var OggParser_1 = require("./ogg/OggParser");
var strtok3 = require("strtok3");
var token_types_1 = require("token-types");
var es6_promise_1 = require("es6-promise");
var path = require("path");
var AiffParser_1 = require("./aiff/AiffParser");
var RiffParser_1 = require("./riff/RiffParser");
var WavPackParser_1 = require("./wavpack/WavPackParser");
var MpegParser_1 = require("./mpeg/MpegParser");
var ParserFactory = /** @class */ (function () {
    function ParserFactory() {
        // ToDo: expose warnings to API
        this.warning = [];
    }
    /**
     * Extract metadata from the given audio file
     * @param filePath File path of the audio file to parse
     * @param opts
     *   .fileSize=true  Return filesize
     *   .native=true    Will return original header in result
     * @returns {Promise<INativeAudioMetadata>}
     */
    ParserFactory.parseFile = function (filePath, opts) {
        if (opts === void 0) { opts = {}; }
        return strtok3.fromFile(filePath).then(function (fileTokenizer) {
            return ParserFactory.getParserForExtension(filePath).then(function (parser) {
                return parser.parse(fileTokenizer, opts).then(function (metadata) {
                    return fileTokenizer.close().then(function () {
                        return metadata;
                    });
                });
            }).catch(function (err) {
                return fileTokenizer.close().then(function () {
                    throw err;
                });
            });
        });
    };
    /**
     * Parse metadata from stream
     * @param stream Node stream
     * @param mimeType The mime-type, e.g. "audio/mpeg", extension e.g. ".mp3" or filename. This is used to redirect to the correct parser.
     * @param opts Parsing options
     * @returns {Promise<INativeAudioMetadata>}
     */
    ParserFactory.parseStream = function (stream, mimeType, opts) {
        if (opts === void 0) { opts = {}; }
        return strtok3.fromStream(stream).then(function (tokenizer) {
            if (!tokenizer.fileSize && opts.fileSize) {
                tokenizer.fileSize = opts.fileSize;
            }
            return ParserFactory.getParserForMimeType(mimeType).then(function (parser) {
                return parser.parse(tokenizer, opts);
            });
        });
    };
    /**
     * @param filePath Path to audio file
     */
    ParserFactory.getParserForExtension = function (filePath) {
        var extension = path.extname(filePath).toLocaleLowerCase() || filePath;
        switch (extension) {
            case ".mp2":
            case ".mp3":
            case ".m2a":
                return es6_promise_1.Promise.resolve(new MpegParser_1.MpegParser());
            case ".ape":
                return es6_promise_1.Promise.resolve(new APEv2Parser_1.APEv2Parser());
            case ".aac":
            case ".mp4":
            case ".m4a":
            case ".m4b":
            case ".m4pa":
            case ".m4v":
            case ".m4r":
            case ".3gp":
                return es6_promise_1.Promise.resolve(new MP4Parser_1.MP4Parser());
            case ".wma":
            case ".wmv":
            case ".asf":
                return es6_promise_1.Promise.resolve(new AsfParser_1.AsfParser());
            case ".flac":
                return es6_promise_1.Promise.resolve(new FlacParser_1.FlacParser());
            case ".ogg":
            case ".ogv":
            case ".oga":
            case ".ogx":
                return es6_promise_1.Promise.resolve(new OggParser_1.OggParser());
            case ".aif":
            case ".aiff":
            case ".aifc":
                return es6_promise_1.Promise.resolve(new AiffParser_1.AIFFParser());
            case ".wav":
                return es6_promise_1.Promise.resolve(new RiffParser_1.WavePcmParser());
            case ".wv":
            case ".wvp":
                return es6_promise_1.Promise.resolve(new WavPackParser_1.WavPackParser());
            default:
                throw new Error("Extension " + extension + " not supported.");
        }
    };
    /**
     * @param {string} mimeType MIME-Type, extension, path or filename
     * @returns {Promise<ITokenParser>}
     */
    ParserFactory.getParserForMimeType = function (mimeType) {
        switch (mimeType) {
            case "audio/mpeg":
                return es6_promise_1.Promise.resolve(new MpegParser_1.MpegParser()); // ToDo: handle ID1 header as well
            case "audio/x-monkeys-audio":
                return es6_promise_1.Promise.resolve(new APEv2Parser_1.APEv2Parser());
            case "audio/aac":
            case "audio/aacp":
            case "audio/mp4":
            case "audio/x-aac":
                return es6_promise_1.Promise.resolve(new MP4Parser_1.MP4Parser());
            case "video/x-ms-asf":
            case "audio/x-ms-wma":
                return es6_promise_1.Promise.resolve(new AsfParser_1.AsfParser());
            case "audio/flac":
            case "audio/x-flac":
                return es6_promise_1.Promise.resolve(new FlacParser_1.FlacParser());
            case "audio/ogg":
            case "application/ogg":
            case "video/ogg":
                return es6_promise_1.Promise.resolve(new OggParser_1.OggParser());
            case "audio/aiff":
            case "audio/x-aif":
            case "audio/x-aifc":
                return es6_promise_1.Promise.resolve(new AiffParser_1.AIFFParser());
            case "audio/wav":
            case "audio/wave":
                return es6_promise_1.Promise.resolve(new RiffParser_1.WavePcmParser());
            case "audio/x-wavpack":
                return es6_promise_1.Promise.resolve(new WavPackParser_1.WavPackParser());
            default:
                // Interpret mimeType as extension
                return ParserFactory.getParserForExtension(mimeType).catch(function () {
                    throw new Error("MIME-Type: " + mimeType + " not supported.");
                });
        }
    };
    // ToDo: obsolete
    ParserFactory.hasStartTag = function (filePath, tagIdentifier) {
        return strtok3.fromFile(filePath).then(function (tokenizer) {
            return tokenizer.readToken(new token_types_1.StringType(tagIdentifier.length, "ascii")).then(function (token) {
                return token === tagIdentifier;
            });
        });
    };
    return ParserFactory;
}());
exports.ParserFactory = ParserFactory;
